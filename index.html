<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://d3js.org/d3-color.v1.min.js"></script>
	<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
	<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
</head>

<body>
	<h1>Heat bulbs</h1>

	<script>
		var margin = {top: 40, right: 40, bottom: 50, left: 40},
		width = 500 - margin.left - margin.right,
		height = 500 - margin.top - margin.bottom;

		// Grille
		var grid = d3.select("body").append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + margin.top + margin.bottom)
		.append("g")
		.attr("transform", "translate(" + margin.left + ", " + margin.top + ")")
		.attr("class", "grid");

    	// Echelle de couleur pour les temperatures (juste pour le début, pour visualiser l'évolution des températures sans notion de record)
    	var color = d3.scaleSequential().interpolator(d3.interpolateTurbo)
    	color.domain([-50, 50])

		

		// Charger le fichier : il faudrait qu'on puisse charger différents fichiers et laisser l'utilisateur choisir s'il veut des villes ou des pays
		d3.csv("https://raw.githubusercontent.com/vdng/heat-bulbs/dev-vincent/GlobalLandTemperaturesByCountry.csv", function(data) {

    	// Parse le temps : 1985-10-23
    	var parse = d3.timeParse("%Y-%m-%d");
    	var minYear = 2000,
    		maxYear = 0;
    	data.forEach(d => {
    		d.dt = parse(d.dt);
    		let year = d.dt.getFullYear();
    		if (year < minYear) minYear = year;
    		if (year > maxYear) maxYear = year;
    	})

    	console.log('minYear', minYear);
    	console.log('maxYear', maxYear);

    	// nest pour formater les données
    	var dataPerCountry = d3.nest()
    		.key(d => d.Country)
    		.entries(data)

    	var countries = dataPerCountry.map(d => d.key);

    	console.log('countries', countries);
    	console.log('dataPerCountry', dataPerCountry);

        // TODO : Mettre NULL si pas de donnée 
        // TODO éventuellement : dynamique sur pas que les années mais aussi par saison ou autre période
        //Nest pour formater les données : regroupées par pays et par année (et on a la moyenne de l'année)
        var dataPerCountryPerYear = d3.nest()
        .key(d => d.Country)
        .key(d => d.dt.getFullYear())
        .rollup(d => {return d3.mean(d, function(e){ return e.AverageTemperature;}) })
        .object(data)

        dataPerCountryPerYear = Object.keys(dataPerCountryPerYear).map(function (key) { return dataPerCountryPerYear[key]; });
        console.log('dataPerCountryPerYear', dataPerCountryPerYear);

        // On enregistre pour chaque pays le maximum courant, ainsi que l'information si on va allumer l'ampoule ou pas (pour pouvoir calculer en amont)
        var maxsTab = {};

        // TODO : année de référence
        for (var i = 0; i < countries.length; i++) {
        	maxsTab[countries[i]] = {"currentMax": dataPerCountryPerYear[i][1950], "vaAllumer": false}
        }
        console.log("maxsTab : ", maxsTab);		

	  	// Création de la grille
	  	var n = Math.ceil(Math.sqrt(dataPerCountry.length));	// Nombre de colonnes
	  	var square_length = Math.floor(width / n);	// longueur d'un côté d'un carré de la grille

	    //console.log(maxsTab);

	    //Grille par défaut
	    grid.selectAll("rect")
		    .data(dataPerCountryPerYear)
		    .enter()
		    .append("rect")
		    .attr("width", square_length)
		    .attr("height", square_length)
		    .attr("x", (d, i) => square_length * (i % n))
		    .attr("y", (d, i) => square_length * Math.floor(i / n))
		    .attr("stroke", "grey")  
			.attr("fill", d => d3.color('white')) //d correspond à un pays, d.values[0] correspond à la première année de ce pays, et value correspond à la température moyenne de cette année

		//Modification de l'affichage de la grille à chaque frame
		var anneeCourante = 0;
		var nbAnnees = maxYear - minYear;    
	    setInterval(() => update(maxsTab), 250) // Durée d'affichage de chaque année
	    function update() {
	    	grid.selectAll("rect")
	    	.transition()
	    	.duration(250)
	    	.attr("fill", (d, i) => {
	      	// Allumage ou pas de la case
	      	if (maxsTab[countries[i]].vaAllumer){
	      		return color(Number(d[minYear + anneeCourante % nbAnnees])) } 
	      		else {
	      			return d3.color('white')
	      		}
	      	});
	    	anneeCourante++;

		    // Parcours des pays pour voir si on dépasse le max
		    // Pour le moment, pas ouf : les premières frames affichent beaucoup d'ampoules allumées. C'est normal, il y a beaucoup de chances de casser son record quand on n'a peu de données : il faudrait pas commencer de la première année mais de la n-ème années en initialisant le max au max des 50 premières années
		    //Bug à partir de 60 ans : trouver pourquoi
		    for (var i = 0; i < countries.length; i++){
		      	country = countries[i];
		      	if (maxsTab[country].currentMax < dataPerCountryPerYear[i][minYear + anneeCourante % nbAnnees]){ //Si on dépasse le max
		      		maxsTab[country].currentMax = dataPerCountryPerYear[i][minYear + anneeCourante % nbAnnees];
		      		maxsTab[country].vaAllumer = true; // Conseil donné par Théo (pas moi, le doctorant) : faire le calcul du booléen maintenant et pas sur le moment de l'affichage
		      	}
		      	else {
		      		maxsTab[country].vaAllumer = false;	
		      	}
		      }
		  }
		})

</script>

</body>
