<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<!-- d3.js -->
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://d3js.org/d3-color.v1.min.js"></script>
	<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
	<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
	<!-- Materialize CSS -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
</head>

<body>

	<nav>
		<div class="nav-wrapper blue">
			<a href="#" class="brand-logo center">Heat Bulbs</a>
		</div>
	</nav>

	<h2 id="year" class="center-align"></h2>

	<script>
		var margin = {top: 40, right: 40, bottom: 50, left: 40},
			width = 1500 - margin.left - margin.right,
			height = 1000 - margin.top - margin.bottom;

		// Grille
		var grid = d3.select("body").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.style("display", "block")
			.style("margin", "auto")
			.append("g")
			.attr("transform", "translate(" + margin.left + ", " + margin.top + ")")
			.attr("class", "grid")


    	// Echelle de couleur pour les temperatures (juste pour le début, pour visualiser l'évolution des températures sans notion de record)
    	var color = d3.scaleSequential().interpolator(d3.interpolateTurbo);

    	var data = [];
    	var rememberRecord = 30;

		// Charger le fichier : il faudrait qu'on puisse charger différents fichiers et laisser l'utilisateur choisir s'il veut des villes ou des pays
		d3.csv("https://raw.githubusercontent.com/vdng/heat-bulbs/dev-vincent/GlobalLandTemperaturesByCountry.csv", function(data_csv) {

    	// Parse le temps : 1985-10-23
    	var parse = d3.timeParse("%Y-%m-%d");
    	var minYear = 2000, maxYear = 0;
    	var minTemp = 50, maxTemp = -50;

    	data_csv.forEach(d => {
    		d.dt = parse(d.dt);
    		let year = d.dt.getFullYear();
    		let temp = Number(d.AverageTemperature);
    		if (year < minYear) minYear = year;
    		if (year > maxYear) maxYear = year;
    		if (temp < minTemp) minTemp = temp;
    		if (temp > maxTemp) maxTemp = temp;
    	})

    	color.domain([minTemp, maxTemp]);

    	console.log('minYear', minYear, 'maxYear', maxYear);
    	console.log('minTemp', minTemp, 'maxTemp', maxTemp);

    	// nest pour formater les données
    	var dataPerCountry = d3.nest()
    		.key(d => d.Country)
    		.entries(data_csv)

    	var countries = dataPerCountry.map(d => d.key);

    	console.log('countries', countries);
    	console.log('dataPerCountry', dataPerCountry);

        // TODO : Mettre NULL si pas de donnée 
        // TODO éventuellement : dynamique sur pas que les années mais aussi par saison ou autre période
        //Nest pour formater les données : regroupées par pays et par année (et on a la moyenne de l'année)
        var tempPerCountryPerYear = d3.nest()
	        .key(d => d.Country)
	        .key(d => d.dt.getFullYear())
	        .rollup(d => {return d3.mean(d, function(e){ return e.AverageTemperature;}) })
	        .object(data_csv)

        console.log('tempPerCountryPerYear', tempPerCountryPerYear);

        var limitPerCountry = d3.nest()
        	.key(d => d.Country)
        	.rollup(d => {return {'minYear': d3.min(d, v => v.dt.getFullYear()), 'maxYear': d3.max(d, v => v.dt.getFullYear())}})
        	.object(data_csv)

        console.log('limitPerCountry', limitPerCountry)

        // TODO : année de référence
        for (var i = 0; i < countries.length; i++) {
        	data[i] = {
        		"country": countries[i],
        		"yearTemperatures": tempPerCountryPerYear[countries[i]],
        		"currentMax": tempPerCountryPerYear[countries[i]][limitPerCountry[countries[i]].minYear],
        		"lastBeaten": rememberRecord,
        		"currentYearAvailable": false,
        		"minYear": limitPerCountry[countries[i]].minYear,
        		"maxYear": limitPerCountry[countries[i]].maxYear
        	}
        }

        console.log('data', data);

	  	// Création de la grille
	  	var n = Math.ceil(Math.sqrt(data.length));	// Nombre de colonnes
	  	var square_length = Math.floor(width / n);	// longueur d'un côté d'un carré de la grille

	    //console.log(maxPerCountry);

	    //Grille par défaut
	    grid.selectAll("rect")
		    .data(data)
		    .enter()
		    .append("rect")
		    .attr("width", square_length)
		    .attr("height", square_length/2)
		    .attr("x", (d, i) => square_length * (i % n))
		    .attr("y", (d, i) => square_length /2* Math.floor(i / n))
		    .attr("stroke", "grey")  
			.attr("fill", d3.color('white')) //d correspond à un pays, d.values[0] correspond à la première année de ce pays, et value correspond à la température moyenne de cette année

		//Modification de l'affichage de la grille à chaque frame
		var yearCount = 0;
		var numYear = maxYear - minYear;    
	    
		let windowsDuration = 250;

	    setInterval(update, windowsDuration) // Durée d'affichage de chaque année

	    function update() {
	    	grid.selectAll("rect")
	    	.transition()
	    	.duration(windowsDuration)
	    	.attr("fill", (d, i) => {
		      	// Allumage ou pas de la case
		      	if (!data[i].currentYearAvailable) return "#eee"
		      	if (data[i].lastBeaten < rememberRecord) return color(Number(d.yearTemperatures[minYear + yearCount % numYear]))
		      	else return d3.color('white')
		      })
	    	.attr("fill-opacity", (d, i) => {
	    		if (!data[i].currentYearAvailable) return 1;
	    		return data[i].lastBeaten < rememberRecord ? 1 - data[i].lastBeaten / rememberRecord : 0
	    	})

	    	d3.select('#year').html('Année : ' + (minYear + yearCount % numYear))

	    	yearCount++;

		    // Parcours des pays pour voir si on dépasse le max
		    // Pour le moment, pas ouf : les premières frames affichent beaucoup d'ampoules allumées. C'est normal, il y a beaucoup de chances de casser son record quand on n'a peu de données : il faudrait pas commencer de la première année mais de la n-ème années en initialisant le max au max des 50 premières années
		    //Bug à partir de 60 ans : trouver pourquoi
		    for (var i = 0; i < countries.length; i++){

		    	if (data[i].yearTemperatures[minYear + yearCount % numYear]) {
		    		data[i].currentYearAvailable = true;
		    	}
		    	else
		    		data[i].currentYearAvailable = false;

		      	if (data[i].currentMax < data[i].yearTemperatures[minYear + yearCount % numYear]){ //Si on dépasse le max
		      		data[i].currentMax = data[i].yearTemperatures[minYear + yearCount % numYear];
		      		data[i].lastBeaten = 0; // Conseil donné par Théo (pas moi, le doctorant) : faire le calcul du booléen maintenant et pas sur le moment de l'affichage
		      	}
		      	else 
		      		data[i].lastBeaten += 1;	
		    }

		    if (yearCount % numYear == 0) {
		    	for (var i = 0; i < countries.length; i++) {
		    		data[i].currentMax = tempPerCountryPerYear[countries[i]][limitPerCountry[countries[i]].minYear];
		    	}
		    }
		}
	})

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>	
</body>
